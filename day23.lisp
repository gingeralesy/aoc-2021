(in-package #:aoc-2021)

;; https://adventofcode.com/2021/day/21

;; Input example:
;; #############
;; #...........#
;; ###B#C#B#D###
;;   #A#D#C#A#
;;   #########

(defparameter *day23-input* (local-file #P"day23.txt" :error T))

(defparameter *day23-input-re* (cl-ppcre:create-scanner "^(##|  )#(\\w)#(\\w)#(\\w)#(\\w)#(##)?$"))

(defparameter *day23-spaces*
  '(:hall-far-west :hall-west :hall-mid-1 :hall-mid-2 :hall-mid-3 :hall-east :hall-far-east
    :room-1-top :room-1-bottom :room-2-top :room-2-bottom
    :room-3-top :room-3-bottom :room-4-top :room-4-bottom))

(defparameter *day23-names* #(:amber :amber :bronze :bronze :copper :copper :desert :desert))

(defparameter *day23-costs* #(1 1 10 10 100 100 1000 1000))

(declaim (inline d23-space-coordinate))
(defun d23-space-coordinate (space)
  (declare (type keyword space))
  (declare (optimize (speed 3)))
  (ecase space
    (:hall-far-west  '(0 . 0))
    (:hall-west      '(1 . 0))
    (:hall-mid-1     '(3 . 0))
    (:hall-mid-2     '(5 . 0))
    (:hall-mid-3     '(7 . 0))
    (:hall-east      '(9 . 0))
    (:hall-far-east '(10 . 0))
    (:room-1-top     '(2 . 1))
    (:room-1-bottom  '(2 . 2))
    (:room-2-top     '(4 . 1))
    (:room-2-bottom  '(4 . 2))
    (:room-3-top     '(6 . 1))
    (:room-3-bottom  '(6 . 2))
    (:room-4-top     '(8 . 1))
    (:room-4-bottom  '(8 . 2))))

(declaim (inline d23-space-from-coordinate))
(defun d23-space-from-coordinate (x y)
  (declare (type (integer 0 10) x))
  (declare (type (integer 0 2) y))
  (declare (optimize (speed 3)))
  (or
   (case x
     (0 (case y (0 :hall-far-west)))
     (1 (case y (0 :hall-west)))
     (2 (case y
          (0 :none)
          (1 :room-1-top)
          (2 :room-1-bottom)))
     (3 (case y (0 :hall-mid-1)))
     (4 (case y
          (0 :none)
          (1 :room-2-top)
          (2 :room-2-bottom)))
     (5 (case y (0 :hall-mid-2)))
     (6 (case y
          (0 :none)
          (1 :room-3-top)
          (2 :room-3-bottom)))
     (7 (case y (0 :hall-mid-3)))
     (8 (case y
          (0 :none)
          (1 :room-4-top)
          (2 :room-4-bottom)))
     (9 (case y (0 :hall-east)))
     (10 (case y (0 :hall-far-east))))
   :wall))

(defun d23-space-distance (space-a space-b)
  (declare (type keyword space-a space-b))
  (declare (optimize (speed 3)))
  (when (eql space-a space-b) (return-from d23-space-distance 0))
  (let* ((start (d23-space-coordinate space-a))
         (end (d23-space-coordinate space-b))
         (start-x (car start))
         (start-y (cdr start))
         (end-x (car end))
         (end-y (cdr end)))
    (declare (type (integer 0 10) start-x end-x))
    (declare (type (integer 0 2) start-y end-y))
    (+ (abs (- end-x start-x)) start-y end-y)))

(defstruct (d23-burrow (:constructor %make-d23-burrow ()))
  (key (make-string 27 :element-type 'base-char :initial-element #\.)
   :type (simple-array base-char (27)))
  (amphipods (make-array 8 :element-type 'keyword :initial-element :none)
   :type (simple-array keyword (8)))
  (spaces (make-array '(3 11) :element-type 'keyword :initial-element :none)
   :type (simple-array keyword (3 11))))

(defmethod d23-burrow-print ((burrow d23-burrow))
  (flet ((amphipod-char (name)
           (ecase name
             (:amber  #\A)
             (:bronze #\B)
             (:copper #\C)
             (:desert #\D)
             (:none   #\.))))
    (let ((spaces (d23-burrow-spaces burrow)))
      (format T "~&#############~%#~c~c.~c.~c.~c.~c~c#~%###~c#~c#~c#~c###~%  #~c#~c#~c#~c#~%  #########~%"
              (amphipod-char (aref spaces 0 0)) (amphipod-char (aref spaces 0 1))
              (amphipod-char (aref spaces 0 3)) (amphipod-char (aref spaces 0 5))
              (amphipod-char (aref spaces 0 7)) (amphipod-char (aref spaces 0 9))
              (amphipod-char (aref spaces 0 10))
              (amphipod-char (aref spaces 1 2)) (amphipod-char (aref spaces 1 4))
              (amphipod-char (aref spaces 1 6)) (amphipod-char (aref spaces 1 8))
              (amphipod-char (aref spaces 2 2)) (amphipod-char (aref spaces 2 4))
              (amphipod-char (aref spaces 2 6)) (amphipod-char (aref spaces 2 8))))))

(defun make-d23-burrow (initial-amphipods)
  (declare (type (simple-array keyword (8)) initial-amphipods))
  (declare (optimize (speed 3)))
  (let* ((burrow (%make-d23-burrow))
         (amphipods (d23-burrow-amphipods burrow))
         (spaces (d23-burrow-spaces burrow)))
    (declare (type (simple-array keyword (8)) amphipods))
    (declare (type (simple-array keyword (3 11)) spaces))
    (dotimes (y 3)
      (dotimes (x 11)
        (setf (aref spaces y x) (if (eql :wall (d23-space-from-coordinate x y)) :wall :none))))
    (dotimes (amphipod 8)
      (let* ((space (aref initial-amphipods amphipod))
             (coord (d23-space-coordinate space))
             (name (svref (the (simple-vector 8) *day23-names*) amphipod)))
        (setf (aref spaces (cdr coord) (car coord)) name)
        (setf (aref amphipods amphipod) space)))
    (d23-burrow-reset-key burrow)))

(defun make-d23-burrow-final ()
  (declare (optimize (speed 3)))
  (make-d23-burrow #(:room-1-top :room-1-bottom
                     :room-2-top :room-2-bottom
                     :room-3-top :room-3-bottom
                     :room-4-top :room-4-bottom)))

(defmethod d23-burrow-reset-key ((burrow d23-burrow))
  (let ((key (d23-burrow-key burrow))
        (spaces (d23-burrow-spaces burrow))
        (i 0))
    (declare (type (integer 0 28) i))
    (dotimes (y 3 burrow)
      (dotimes (x 11)
        (let ((space (aref spaces y x)))
          (case space
            (:amber  (setf (char key i) #\A))
            (:bronze (setf (char key i) #\B))
            (:copper (setf (char key i) #\C))
            (:desert (setf (char key i) #\D))
            (:none   (setf (char key i) #\.)))
          (unless (eql :wall space)
            (incf i)))))))

(defmethod d23-burrow-copy ((burrow d23-burrow))
  (declare (optimize (speed 3)))
  (let ((copy (%make-d23-burrow)))
    (dotimes (i 8)
      (setf (aref (d23-burrow-amphipods copy) i) (aref (d23-burrow-amphipods burrow) i)))
    (dotimes (y 3 copy)
      (dotimes (x 11)
        (setf (aref (d23-burrow-spaces copy) y x) (aref (d23-burrow-spaces burrow) y x))))))

(defmethod d23-burrow-moves-from ((burrow d23-burrow) from output)
  (declare (type keyword from))
  (declare (type (simple-array keyword (15)) output))
  (declare (optimize (speed 3)))
  (let ((spaces (d23-burrow-spaces burrow)))
    (declare (type (simple-array keyword (3 11)) spaces))
    (dotimes (i 15) (setf (aref output i) :none)) ;; Initialise.
    (let* ((coord (the cons (d23-space-coordinate from)))
           (from-x (car coord))
           (from-y (cdr coord))
           (name (aref spaces from-y from-x))
           (room-x (ecase name
                     (:amber 2)
                     (:bronze 4)
                     (:copper 6)
                     (:desert 8)))
           (blocked-p T)
           (count 0))
      (declare (type (integer 0 10) from-x))
      (declare (type (integer 0 2) from-y))
      (when (or (and (= from-x room-x) (eql name (aref spaces 2 room-x)))
                (and (= from-y 2) (not (eql :none (aref spaces 1 from-x)))))
        (return-from d23-burrow-moves-from 0))
      (loop for x from (1- from-x) downto 0
            while (eql :none (aref spaces 0 x))
            when (= x room-x) do (setf blocked-p NIL)
            do (when (< 0 from-y)
                 (let ((space-name (d23-space-from-coordinate x 0)))
                   (unless (eql :none space-name)
                     (setf (aref output count) space-name)
                     (incf count)))))
      (loop for x from (1+ from-x) upto 10
            while (eql :none (aref spaces 0 x))
            when (= x room-x) do (setf blocked-p NIL)
            do (when (< 0 from-y)
                 (let ((space-name (d23-space-from-coordinate x 0)))
                   (unless (eql :none space-name)
                     (setf (aref output count) space-name)
                     (incf count)))))
      (when (and (not blocked-p) (eql :none (aref spaces 1 room-x)))
        (cond
          ((eql :none (aref spaces 2 room-x))
           (setf (aref output count) (d23-space-from-coordinate room-x 2))
           (incf count))
          ((eql name (aref spaces 2 room-x))
           (setf (aref output count) (d23-space-from-coordinate room-x 1))
           (incf count))))
      count)))

(defmethod d23-burrow-move ((burrow d23-burrow) from to)
  (declare (optimize (speed 3)))
  (declare (type keyword from to))
  (let* ((spaces (d23-burrow-spaces burrow))
         (amphipods (d23-burrow-amphipods burrow))
         (from-coord (d23-space-coordinate from))
         (from-x (car from-coord))
         (from-y (cdr from-coord))
         (to-coord (d23-space-coordinate to))
         (to-x (car to-coord))
         (to-y (cdr to-coord))
         (name (aref spaces from-y from-x))
         (amphipod (ecase name
                     (:amber 0)
                     (:bronze 2)
                     (:copper 4)
                     (:desert 6)
                     (:none (error "Space is empty at ~a" to)))))
    (unless (eql :none (aref spaces to-y to-x))
      (error "Space is full at ~a" to))
    (cond
      ((eql from (aref amphipods amphipod))
       (setf (aref amphipods amphipod) to))
      ((eql from (aref amphipods (1+ amphipod)))
       (setf (aref amphipods (1+ amphipod)) to))
      (T (error "Amphipod ~a is not at ~a" name from)))
    (setf (aref spaces to-y to-x) name)
    (setf (aref spaces from-y from-x) :none)
    (d23-burrow-reset-key burrow)
    (* (the (integer 0 1000) (svref (the (simple-vector 8) *day23-costs*) amphipod))
       (the (integer 0 10) (d23-space-distance from to)))))

(defstruct (d23-queue (:constructor %make-d23-queue ()))
  (count 0 :type (unsigned-byte 32))
  (size #x100 :type (unsigned-byte 32))
  (start 0 :type (unsigned-byte 32))
  (array (make-array #x100) :type (simple-array T (*))))

(defmethod d23-queue-expand ((queue d23-queue))
  (declare (optimize (speed 3)))
  (with-slots (count size start array) queue
    (declare (type (unsigned-byte 32) count size start))
    (declare (type (simple-array T (*)) array))
    (unless (< count (1- size))
      (let ((new-array (make-array (* 2 size))))
        (declare (type (simple-array T (*)) new-array))
        (dotimes (i count)
          (setf (aref new-array i) (aref array (mod (+ i start) size))))
        (setf start 0)
        (setf size (* 2 size))
        (setf array new-array)
        queue))))

(defmethod d23-queue-push ((queue d23-queue) value)
  (declare (optimize (speed 3)))
  (d23-queue-expand queue)
  (with-slots (count size start array) queue
    (declare (type (unsigned-byte 32) count size start))
    (declare (type (simple-array T (*)) array))
    (setf (aref array (mod (+ start count) size)) value)
    (setf count (1+ count))
    queue))

(defmethod d23-queue-pop ((queue d23-queue))
  (declare (optimize (speed 3)))
  (with-slots (count size start array) queue
    (declare (type (unsigned-byte 32) count size start))
    (declare (type (simple-array T (*)) array))
    (when (< 0 count)
      (setf count (1- count))
      (let ((value (aref array start)))
        (setf (aref array start) NIL)
        (setf start (mod (1+ start) size))
        value))))

(defmethod d23-astar ((root d23-burrow) &optional debug-p)
  (declare (optimize (speed 3)))
  (let ((moves (make-array 15 :element-type 'keyword :initial-element :none)))
    (flet ((weight (astar from to)
             (declare (type astar astar))
             (declare (type d23-burrow from to))
             (declare (ignore astar))
             (declare (optimize (speed 3)))
             (let ((name :none)
                   (cost 0)
                   (from-space :none)
                   (to-space :none)
                   (from-amphipods (d23-burrow-amphipods from))
                   (to-amphipods (d23-burrow-amphipods to)))
               (declare (type (integer 0 1000) cost))
               (dotimes (amphipod 8)
                 (let ((cur-name (svref (the (simple-vector 8) *day23-names*) amphipod))
                       (cur-cost (svref (the (simple-vector 8) *day23-costs*) amphipod)))
                   (unless (eql (aref from-amphipods amphipod) (aref to-amphipods amphipod))
                     (unless (eql :none name)
                       (error "Multiple moves between states ~a and ~a" from to))
                     (setf name cur-name)
                     (setf cost cur-cost)
                     (setf from-space (aref from-amphipods amphipod))
                     (setf to-space (aref to-amphipods amphipod)))))
               (* (the (unsigned-byte 32) (d23-space-distance from-space to-space)) cost)))
           (heuristic (astar burrow)
             (declare (type astar astar))
             (declare (type d23-burrow burrow))
             (declare (ignore astar))
             (declare (optimize (speed 3)))
             (loop with spaces = (d23-burrow-spaces burrow)
                   with amphipods = (d23-burrow-amphipods burrow)
                   with total-cost of-type (unsigned-byte 32) = 0
                   for amphipod from 0 below 8
                   for name = (svref (the (simple-vector 8) *day23-names*) amphipod)
                   for cost of-type (integer 0 1000) =
                   (svref (the (simple-vector 8) *day23-costs*) amphipod)
                   for space = (aref amphipods amphipod)
                   for coord = (d23-space-coordinate space)
                   for x of-type (integer 0 10) = (car coord)
                   for y of-type (integer 0 2) = (cdr coord)
                   for room-x = (the (integer  0 10) (* 2 (1+ (floor amphipod 2))))
                   unless (and (= x room-x) (or (= y 2) (eql (aref spaces 2 x) name)))
                   do (setf total-cost
                            (+ total-cost
                               (* cost (+ (if (= x room-x) 2 (abs (- room-x x))) y
                                          (if (eql (aref spaces 2 room-x) name)
                                              1 (1+ (mod amphipod 2)))))))
                   finally (return total-cost)))
           (neighbors (astar burrow)
             (declare (type astar astar))
             (declare (type d23-burrow burrow))
             (declare (ignore astar))
             (declare (optimize (speed 3)))
             (loop with amphipods = (d23-burrow-amphipods burrow)
                   for amphipod from 0 below 8
                   for from-space = (aref amphipods amphipod)
                   for move-count of-type (integer 0 15) =
                   (d23-burrow-moves-from burrow from-space moves)
                   nconc (loop for i from 0 below move-count
                               for to-space = (aref moves i)
                               for copy = (d23-burrow-copy burrow)
                               do (d23-burrow-move copy from-space to-space)
                               collect copy))))
      (let ((astar (make-astar :start root
                               :goal (make-d23-burrow-final)
                               :key-f #'d23-burrow-key
                               :weight-f #'weight
                               :heuristic-f #'heuristic
                               :neighbors-f #'neighbors)))
        (loop with steps = (astar-find astar)
              with total-cost of-type (unsigned-byte 32) = 0
              for prev = (car steps) then current
              for current in (rest steps)
              do (when debug-p
                   (d23-burrow-print prev)
                   (format T "~&~%")
                   (force-output T))
              do (setf total-cost (+ total-cost (weight astar prev current)))
              finally (return (prog1 total-cost
                                (when (and prev debug-p) (d23-burrow-print prev)))))))))

(defun d23-data ()
  (declare (optimize (speed 3)))
  (with-open-file (stream *day23-input* :if-does-not-exist :error)
    (flet ((amphipod-index (str)
             (declare (type (simple-array character (1)) str))
             (ecase (char str 0)
               (#\A 0)
               (#\B 2)
               (#\C 4)
               (#\D 6))))
      (let ((amphipods (make-array 8 :element-type 'keyword :initial-element :none))
            (top-p T))
        (declare (type boolean top-p))
        (dolist (expected '("#############" "#...........#" :regex :regex "  #########"))
          (let ((line (read-line stream)))
            (declare (type (simple-array character (*)) line))
            (unless (or (eql :regex expected) (string= line expected))
              (error "Invalid input \"~a\" when expected \"~a\"" line expected))
            (when (eql :regex expected)
              (multiple-value-bind (match groups) (cl-ppcre:scan-to-strings *day23-input-re* line)
                (declare (type (simple-array (simple-array character (*)) (*)) groups))
                (unless match (error "Invalid input: ~a" line))
                (let ((index (amphipod-index (aref groups 1))))
                  (unless (eql :none (aref amphipods index)) (incf index))
                  (setf (aref amphipods index) (if top-p :room-1-top :room-1-bottom)))
                (let ((index (amphipod-index (aref groups 2))))
                  (unless (eql :none (aref amphipods index)) (incf index))
                  (setf (aref amphipods index) (if top-p :room-2-top :room-2-bottom)))
                (let ((index (amphipod-index (aref groups 3))))
                  (unless (eql :none (aref amphipods index)) (incf index))
                  (setf (aref amphipods index) (if top-p :room-3-top :room-3-bottom)))
                (let ((index (amphipod-index (aref groups 4))))
                  (unless (eql :none (aref amphipods index)) (incf index))
                  (setf (aref amphipods index) (if top-p :room-4-top :room-4-bottom)))
                (setf top-p NIL)))))
        (let ((line (read-line stream NIL :eof)))
          (unless (eql :eof line)
            (error "Excess content: ~a" line)))
        (make-d23-burrow amphipods)))))

(defun d23p1 (&optional debug-p)
  (declare (optimize (speed 3)))
  (let ((burrow (d23-data)))
    (d23-astar burrow debug-p)))

;; Answer: 11516
